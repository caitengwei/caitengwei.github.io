---
status: publish
published: true
title: C++学习笔记整理
author:
  display_name: twcai
  login: admin
  email: clumsywyvern@gmail.com
  url: http://www.caitengwei.com
author_login: admin
author_email: clumsywyvern@gmail.com
author_url: http://www.caitengwei.com
excerpt: "最近一直在翻Windows核心编程，记笔记时发现以前看C++写的一些东西，决定好好整理下，当作复习。\r\n\r\n<strong>指针和迭代器<&#47;strong>：\r\nconst_iterator是指向const的对象的迭代器，类似const
  ctype *ptr，无法通过它给所指的对象赋值。\r\n注意：用iterator访问vector时，vector长度的改变可能使iterator失效； 把const的对象地址赋给一个非const的指针是非法的。\r\n\r\n<strong>常量指针<&#47;strong>:\r\n<pre
  class=\"prettyprint\">\r\nctype *const ptr = &val;\r\n\r\n&#47;&#47; 下面是另一种用法：\r\ntypedef
  string *pstring;\r\nconst pstring cstr;\r\n<&#47;pre>\r\n\r\n<strong>指向多维数组的指针的使用<&#47;strong>：\r\n<pre
  class=\"prettyprint\">\r\nint a[3][5];\r\nint (*p)[5] = a;\r\n<&#47;pre>\r\n\r\n<strong>delete函数<&#47;strong>：\r\n在释放指向数组的指针指向的内存时，不要遗漏方括号。这是内存泄漏的原因之一。\r\n正确做法：delete
  [] arrayname;\r\n"
wordpress_id: 679
wordpress_url: http://caitengwei.com/blog/?p=679
date: '2010-02-05 05:42:23 +0800'
date_gmt: '2010-02-05 13:42:23 +0800'
categories:
- C&#47;C++
tags:
- cpp
- "指针"
- "迭代器"
- "内存泄漏"
comments: []
---
<p>最近一直在翻Windows核心编程，记笔记时发现以前看C++写的一些东西，决定好好整理下，当作复习。</p>
<p><strong>指针和迭代器<&#47;strong>：<br />
const_iterator是指向const的对象的迭代器，类似const ctype *ptr，无法通过它给所指的对象赋值。<br />
注意：用iterator访问vector时，vector长度的改变可能使iterator失效； 把const的对象地址赋给一个非const的指针是非法的。</p>
<p><strong>常量指针<&#47;strong>:</p>
<pre class="prettyprint">
ctype *const ptr = &val;</p>
<p>&#47;&#47; 下面是另一种用法：<br />
typedef string *pstring;<br />
const pstring cstr;<br />
<&#47;pre></p>
<p><strong>指向多维数组的指针的使用<&#47;strong>：</p>
<pre class="prettyprint">
int a[3][5];<br />
int (*p)[5] = a;<br />
<&#47;pre></p>
<p><strong>delete函数<&#47;strong>：<br />
在释放指向数组的指针指向的内存时，不要遗漏方括号。这是内存泄漏的原因之一。<br />
正确做法：delete [] arrayname;<br />
<a id="more"></a><a id="more-679"></a><br />
<strong>函数指针<&#47;strong>：<br />
定义一个函数指针跟定义一个多维数组指针比较像，需要用到括号。<br />
e.g.	</p>
<pre class="prettyprint">
int (*ptr) (const int &, const int &);</p>
<p>&#47;&#47; 下面的方法与上一行等价<br />
typedef int (*CMP) (const int &, const int &);<br />
int IntegerCmp (const int &, const int &);<br />
CMP cmp = IntegerCmp;</p>
<p>&#47;&#47; 调用函数指针：<br />
cmp(1, 2);<br />
<&#47;pre><br />
<br &#47;><br />
<strong>更容易混淆的是返回函数指针的函数<&#47;strong>：<br />
e.g.<br />
int (*foo(int)) (int, int);<br />
这个函数返回的是一个指向函数的指针：int (*) (int , int)</p>
<p><strong>构造函数初始化列表的用法<&#47;strong>：<br />
e.g.</p>
<pre class="prettyprint">
class Example {<br />
public:<br />
	string str;</p>
<p>	Example(const string &s) : str(s) {};<br />
};<br />
<&#47;pre><br />
<br &#47;><br />
<strong>构造函数定义的隐式转换<&#47;strong>：<br />
e.g.</p>
<pre class="prettyprint">
class Example2 {<br />
public:<br />
	Example ex;<br />
	int cnt;</p>
<p>	Example2(const Example &x) : ex(x), cnt(0) { };<br />
};</p>
<p>&#47;&#47; 调用<br />
string stmp = "This is an example.";<br />
Example2 ex2(stmp);<br />
<&#47;pre><br />
<br &#47;><br />
<strong>默认实参<&#47;strong>：<br />
主要需要注意参数顺序问题。默认的参数必须靠右，不能与实际接受的参数交错。</p>
