---
title: "作为一个命令行偏执狂..."
date: 2011-11-01 08:50:52.000000000 +08:00
categories:
- Perl
tags:
- LWP
- Perl
- XPath
- "字典"
status: publish
type: post
published: true
meta:
  _edit_last: '1'
author:
  login: admin
  email: tengweicai@gmail.com
  display_name: twcai
  first_name: Tengwei
  last_name: Cai
---
<p>好久没有更新博客了，这次更新的原因是上次贴的<a href="./programming/perl/perl脚本查google字典/" target="_blank">Perl脚本查Google字典</a>因为Google关闭字典服务的关系已经不能再用了。</p>
<p>前段时间接触了一个新东西叫XPath，名字听起来挺酷的，于是拿来又折腾了一个脚本出来。这次查的是有道辞典，没有Google的好用，但因为Google字典已经不再提供服务，目前能找到的Google字典服务都是通过Unofficial API实现的，也不知道能用多久，就先这么凑合着用吧。</p>
<p>上图<br />
<a href="http://caitengwei.com/blog/wp-content/uploads/2011/11/youdao_dict.jpg"><img alt="youdao_dict " src="http://caitengwei.com/blog/wp-content/uploads/2011/11/youdao_dict.jpg" title="youdao_dict" width="640" height="400" /></a><br />
<br />
这次脚本代码还是主要分两部分，一部分是通过LWP::UserAgent抓网页内容，一部分是用HTML::TreeBuilder::XPath分析网页内容提取需要的数据。</p>
<ul>
<li>XPath其实是一门用来在XML文档中查找信息的语言，比较简单的说就是他能用一个路径表达式定位到一个XML文档里面的某个（或某几个）标签。因为XHTML借鉴了XML的结构，所以我们也可以用XPath来定位XHTML网页中的某个特定标签（XPath几乎总是能定位到一个正常网页中的特定标签的）。
</li>
<p></p>
<li>
在原来使用的网页解析模块HTML::TokenParser中，所有网页标签都按出现顺序排列，并且标签之间都是并列的关系。但是没有一个Browser DEV tool会用这种结构给开发者展示网页源代码，即便我们写代码时也不会这样写。所以这样并列的结构其实对开发者来说是不直观的，也使得编码复杂了很多。
</li>
<p></p>
<li>
而在XPath的世界里，网页的结构是树型的，每个标签都是这棵树上的结点或叶子，开发者会发现很容易就能找出一个路径通往我们想要的那个标签。不过如果你有Firebug和FireFinder这两个网页开发辅助插件，你会发现用起XPath来更加得心应手。
</li>
</ul>
<p>
直接对比下面一个脚本和<a href="./programming/perl/perl脚本查google字典/" target="_blank">上一个脚本</a>中网页分析部分的代码，你就能直观的感受到上面提到这两种方法的差别。XPath的详细介绍和语法，请猛击<a href="http://www.w3school.com.cn/xpath/index.asp" target="_blank">W3school</a><!--more--></p>
<p><coolcode lang="perl">#!/usr/bin/perl<br />
use strict;<br />
use warnings;<br />
use IO::Scalar;<br />
use LWP::UserAgent;<br />
use HTML::TreeBuilder::XPath;<br />
use URI::Escape;<br />
use Data::Dumper;<br />
use encoding "utf-8";</p>
<p>my $keyword = $ARGV[0];<br />
die "You must pass a Chinese/English word as parameter" if ( ! $keyword );</p>
<p>my $url  = 'http://dict.youdao.com/search?q=KEYW0RD&ue=utf8';<br />
$keyword = uri_escape( $keyword );<br />
$url     =~ s/KEYW0RD/$keyword/;</p>
<p>my $ua = LWP::UserAgent->new;<br />
$ua->timeout(30);<br />
$ua->env_proxy;</p>
<p>my $page = $ua->get( $url );<br />
die "Cannot connect to youdao dictionary" unless ( $page->is_success );</p>
<p>my $buffer;<br />
my $screen = IO::Scalar->new( \$buffer );<br />
my $tree   = HTML::TreeBuilder::XPath->new_from_content( $page->decoded_content );</p>
<p>get_translation( $tree, $screen );<br />
print $buffer;</p>
<p>END {<br />
    $tree->delete();<br />
}</p>
<p>sub get_translation {<br />
    my ( $tree, $screen ) = @_;<br />
    my $indent = 2;<br />
    if ( ! $tree->exists('//div[@class=\'trans-wrapper\'][not(@id)]') ) {<br />
        $screen->print( "Cannot find the translation on the page\n" );<br />
        return 1;<br />
    }<br />
    else {<br />
        # Get the spell and phonetic of the word<br />
        $screen->print( $tree->findvalue('//div[@class=\'trans-wrapper\'][not(@id)]/h2'), "\n" );<br />
        $screen->print( "\n" );<br />
    }</p>
<p>    if ( $tree->exists('//div[@id=\'eTransform\']') ) {<br />
        # Get the basic translation of the word<br />
        $screen->print( $tree->findvalue('//div[@id=\'eTransform\']/h3/span/a[@rel=\'#etcTrans\']/span'), "\n" );<br />
        my @translation_list = $tree->findvalues( '//div[@id=\'eTransform\']/div/div[@id=\'etcTrans\']/ul/' . 'li' );<br />
        if ($#translation_list == -1 ) {<br />
            # If didn't get any translation, it may be a chinese word<br />
            @translation_list = $tree->findvalues( '//div[@id=\'eTransform\']/div/div[@id=\'etcTrans\']/ul/' . 'p' );<br />
        }<br />
        foreach (@translation_list) {<br />
            $screen->print( ' ' x $indent, trim( $_ ), "\n" );<br />
        }<br />
        $screen->print( "\n" );<br />
    }</p>
<p>    if ( $tree->exists('//div[@id=\'examples\']') ) {<br />
        # Get the examples of the word<br />
        my @examples_id   = qw(bilingual originalSound authority);<br />
        my @examples_name = split( /\s+/, trim( $tree->findvalue('//div[@id=\'examples\']/h3') ) );<br />
        foreach my $index ( 0 .. 2 ) {<br />
            my $xpath = '//div[@id=\'examples\']/div/div[@id=\'' . $examples_id[$index] . '\']';<br />
            next if ( ! $tree->exists( $xpath ) );<br />
            $screen->print( shift @examples_name, "\n" );<br />
            my @examples_list    = $tree->findvalues( "$xpath/ul/li/" . "p[not(\@class)]" );<br />
            my $is_a_translation = 0;<br />
            foreach (@examples_list) {<br />
                $screen->print( ' ' x $indent, $is_a_translation ? "~ $_" : $_, "\n" );<br />
                $is_a_translation ^= 1 if ( $index < 2 );<br />
            }<br />
            $screen->print( "\n" );<br />
        }<br />
    }</p>
<p>}</p>
<p>sub trim {<br />
    my $string = shift;<br />
    $string =~ s/^\s*(.*?)\s*$/$1/;<br />
    return $string;<br />
}<br />
</coolcode></p>
